//
// Created by william on 2021/1/3.
//
/**
 * 构造函数与成员初始化器列表
 * 构造函数是类的一种特殊的非静态成员函数，用于初始化该类类型的对象。
 * 在类的构造函数定义中，成员初始化器列表指定各个直接和虚基类和各个非静态数据成员的初始化器。
 * 构造函数必须不是协程 Coroutines
 */

/**
 * 语法:
 * 构造函数用下列形式的成员函数声明符声明：
 * 类名 ( 形参列表(可选) ) 异常说明(可选) attr(可选)
 */

/**
 * 构造函数没有名字且无法被直接调用。它们在发生初始化时调用，且它们按照初始化的规则进行选择。无 explicit 说明符的构造函数是转换构造函数
 * 有 constexpr 说明符的构造函数令其类型成为字面类型 (LiteralType) 。可以不带任何实参调用的构造函数是默认构造函数。
 * 可以接收同类型的另一对象为实参的构造函数是复制构造函数和移动构造函数。
 */

/**
 * 成员初始化器所抛出的异常可被函数 try 块处理。成员函数（包括虚成员函数）可从成员初始化器调用，但若在该点所有直接基类尚未全部被初始化，则行为未定义
 * 对于虚调用（若在该点已初始化直接基类）适用与从构造函数与析构函数中进行虚函数调用相同的规则,虚成员函数表现如同 *this 的动态类型是正在构造的类的静态类型（动态派发不在继承层级下传）
 * 而对纯虚成员函数的虚调用（但非静态调用）是未定义行为。
 * 若非静态数据成员具有 默认成员初始化器且亦出现于成员初始化器列表中，则使用该成员初始化器而忽略默认成员初始化器：
 */

class X
{
    int a, b, i, j;

public:
    const int& r;
    X(int i) :
        r(a),      // 初始化 X::r 为指代 X::a
        b(i),      // 初始化 X::b 为形参 i 的值
        i(i),      // 初始化 X::i 为形参 i 的值
        j(this->i) // 初始化 X::j 为 X::i 的值
    {}
};

struct S
{
    int n = 42; // 默认成员初始化器 C++ 11
    S(int);     // 构造函数声明
    S() :
        n(7) {} // 构造函数定义。": n(7)" 为初始化器列表,": n(7) {}" 为函数体, 因为有默认初始化起，所以这边是将设置 n 为 7，而非 42
    // 引用成员不能绑定到成员初始化器列表中的临时量：
};

S::S(int x) :
    n{ x }
{} // 构造函数定义。": n{x}" 为初始化器列表

/**
 * 委托构造函数
 * 若类自身的名字在初始化器列表中作为 类或标识符 出现，则该列表必须仅由这一个成员初始化器组成；
 * 这种构造函数被称为委托构造函数（delegating constructor），而构造函数列表的仅有成员所选择的构造函数是目标构造函数
 * 此情况下，首先由重载决议选择目标构造函数并予以执行，然后控制返回到委托构造函数并执行其函数体。委托构造函数不能递归。
 */

class Foo
{
public:
    Foo(char x, int y) {}
    Foo(int y) :
        Foo('a', y) {} // Foo(int) 委托到 Foo(char,int) C++ 11
};

/**
 * 继承的构造函数
 * 若 using 声明指代正在定义的类的某个直接基类的构造函数，（例如 using Base::Base;）则在初始化派生类时，令该基类的所有构造函数（忽略成员访问）均对重载决议可见。
 * 若重载决议选择了继承的构造函数，则当它被用于构造相应基类的对象时可访问，它是可访问的：引入它的 using 声明的可访问性被忽略。
 * 若在初始化这种派生类对象时重载决议选择了继承的构造函数之一，
 * 则用这个继承的构造函数，对从之继承该构造函数的 Base 子对象进行初始化，
 * 而 Derived 的所有其他基类和成员，都如同以预置的默认构造函数一样进行初始化（若提供默认成员初始化器则使用之，否则进行默认初始化）。
 * 整个初始化被视作单个函数调用：继承的构造函数的各形参的初始化，按顺序早于派生类对象的任何基类或成员的初始化。
 */

struct B1
{
    B1(int, ...) {}
};

struct B2
{
    B2(double) {}
};

//int get();

struct D1 : B1
{
    using B1::B1; // // 继承 B1(int, ...)
    int x;
//    int y = get();
};

void 委托构造test()
{
    D1 d(2, 3, 4); // ok， B1 通过调用 B1(2, 3, 4) 初始化，
                   // 然后 d.x 被默认初始化（不进行初始化）
                   // 然后 d.y 通过调用 get() 初始化
    //    D1 e;                //  错误：D1 无默认构造函数
}

struct D2 : B2
{
    using B2::B2; // 继承 B2(double)
    B1 b;
};

//D2 f(1.0); // // 错误：B1 无默认构造函数

struct W
{
    W(int);
};
struct X1 : virtual W
{
    using W::W; //继承 W(int)
    X1() = delete;
};

struct Y : X1
{
    using X1::X1;
};

struct Z : Y, virtual W
{
    using Y::Y;
};

//Z z(0); // ok:Y 的初始化不调用 X 的默认构造函数

// 若构造函数从 B 类型的多个基类子对象继承，则程序非良构，这与多继承的非静态成员函数相似：

#include <fstream>
#include <mutex>
#include <string>

struct Base
{
    int n;
};

struct Class : public Base
{
    unsigned char x;
    unsigned char y;

};